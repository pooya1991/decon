# Unlike other scripts, this ones does not get system inputs. In fact this scripts is not
# meant to be used in the pipeline. It's for testing ideas about regression methods
# for deconvolution

source("matrix_operations.R")

# The name of ydir and outdir is dependent to the names of folders created by siren
# at previous steps
ydir <- "15b_ms1_sparsebinned_singlescans_tannotated/"
xdir <- ydir
outdir <- "15b_peptide_abundances/"

xfiles <- list.files(xdir) %>%
	stringr::str_subset("xdecoy\\.txt")

idx_ordered <- stringr::str_extract(xfiles, "^\\d+") %>%
	as.integer() %>%
	order()

xfiles <- xfiles[idx_ordered]
yfiles <- stringr::str_replace(xfiles, "xdecoy", "y")

if (!dir.exists(outdir)) {
	dir.create(outdir)
}

numjobs <- 0

input_files <- purrr::map2(xfiles, yfiles, c) %>%
	purrr::map(~ paste0(xdir, .x))

# subX_list is a list of X matrices obtained by dissolving xfiles. each element of
# subX_list corresponds to the X matrix for a single scan. The same applies for subY_list
subX_list <- list()
subY_list <- list()
# Each element of sub_binbounds_list correspond to binbounds (clusters) for the X matrix
# in the same scan
sub_binbounds_list <- list()

for (i in seq_along(input_files)) {
	x <- readLines(input_files[[i]][1])
	y <- readLines(input_files[[i]][2])
	scans <- get_scannum(x)
	unique_scans <- unique(scans)
	binbounds <- get_binbounds(x)
	X <- sparse_to_regular(x)
	Y <- sparse_to_regular(y)
	subX <- vector("list", length(unique_scans)) %>% set_names(unique_scans)
	subY <- vector("list", length(unique_scans)) %>% set_names(unique_scans)
	sub_binbounds <- vector("list", length(unique_scans)) %>% set_names(unique_scans)

	for (j in unique_scans) {
		# idx_rows are the indices of rows in scan j
		idx_rows <- scans[scans == j] %>% names() %>% as.integer()
		subX[[as.character(j)]] <- X[idx_rows, ]
		# At each scan, we onlly keep nonzero columns to reduce dimensionality
		idx_nonzero_cols <- colSums(subX[[as.character(j)]]) > 0
		subX[[as.character(j)]] <- subX[[as.character(j)]][, idx_nonzero_cols]
		subY[[as.character(j)]] <- Y[idx_rows, , drop = FALSE]
		sub_binbounds[[as.character(j)]] <- binbounds[rownames(binbounds) %in% idx_rows, ]
	}

	subX_list <- c(subX_list, subX)
	subY_list <- c(subY_list, subY)
	sub_binbounds_list <- c(sub_binbounds_list, sub_binbounds)
}

# Each element offffff mdl_list is a model generated by glmnet. to keep the ful path
# cv.glmnet could be substituted with glmnet
mdl_list <- map2(subX_list, subY_list,
				 ~glmnet::cv.glmnet(x = .x, y = .y, intercept = FALSE, lower.limits = 0, alpha = 0.5))

# For each model, we extract the coefficients
coef_list <- map2(mdl_list, subX_list, ~predict(.x, .y, s ="lambda.min", type = "coef")) %>%
	map(as.vector) %>%
	# This removes to intercept
	map(~.x[-1])

output_mats <- map2(subX_list, coef_list, ~ t(apply(.x, 1, function(x) x * .y)))

# This converts element of subX_list to sparse format to reduce their sizes
subX_sparse_list <- map(subX_list, Matrix::Matrix, sparse = TRUE)
output_mats_sparse <- map(output_mats, Matrix::Matrix, sparse = TRUE)
save(subX_sparse_list, subY_list, sub_binbounds_list, coef_list, output_mats_sparse,
	 file = "elnet_outputs.RData")

